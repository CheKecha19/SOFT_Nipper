<#
.SYNOPSIS
    Скрипт для анализа конфигураций сетевого оборудования с помощью Nipper
.DESCRIPTION
    Дёргает .txt файлы из inputfolder, проверяет на уязвимости и выдаёт отчёты в outputfolder
.NOTES
    File Name      : nipper_list_checker.ps1
    Author        : Ваше имя
    Prerequisite  : PowerShell 5.1+, Nipper
#>

#region Инициализация
cls

# Установка кодировки для корректной работы с русскими символами
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# Объявляем пути
$NipperExePath       = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\scanner"
$nipperExecutable    = "$NipperExePath\nipper.exe"
$StartupConfigsPath  = "\\uni-imc\cfgbak$"
$NewConfigsPath      = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\source_configs"
$inputFolder         = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\configs"
$outputFolder        = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\results"
$logFile             = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\nipper_log_$(Get-Date -Format 'yyyyMMdd').txt"

# Создаем лог-файл
Start-Transcript -Path $logFile -Append -Force
#endregion

#region Вспомогательные функции
function Test-Paths {
    param([Parameter(Mandatory=$true)][array]$Paths)
    
    foreach ($path in $Paths) {
        if (-not (Test-Path -Path $path)) {
            Write-Host "ОШИБКА: Путь не существует - $path" -ForegroundColor Red
            return $false
        }
        Write-Host "Путь существует: $path" -ForegroundColor Green
    }
    return $true
}








function Get-NipperVulnerabilities {
    param(
        [string]$htmlPath
    )
    
    try {
        Write-Host "Обработка файла: $htmlPath" -ForegroundColor Cyan
        $htmlContent = Get-Content -Path $htmlPath -Raw -Encoding UTF8
        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($htmlPath)
        $deviceName = $fileName -replace '_\d{8}_\d{6}|\.html$'
        
        $vulnerabilities = @{}
        
        # 1. Ищем основной раздел Security Audit
        if ($htmlContent -match '<h2>2\.\s*<a\s+name="SECURITYSECTION">Security\s+Audit<\/a><\/h2><br>(.*?)(?:<h2>|\z)') {
            $auditSection = $matches[1]
            
            # 2. Ищем подраздел Recommendations (любой номер)
            if ($auditSection -match '<h3>2\.(\d+)\.\s*Recommendations<\/h3><br>(.*?)(?:<h3>|\z)') {
                $recommendationsSection = $matches[2]
                
                # 3. Ищем таблицу внутри этого подраздела
                if ($recommendationsSection -match '<table.*?>(.*?)<\/table>') {
                    $tableContent = $matches[1]
                    
                    # 4. Извлекаем тело таблицы
                    if ($tableContent -match '<tbody>(.*?)<\/tbody>') {
                        $tbody = $matches[1]
                        
                        # 5. Парсим строки таблицы
                        $rowMatches = [regex]::Matches($tbody, '<tr.*?>(.*?)<\/tr>', [System.Text.RegularExpressions.RegexOptions]::Singleline)
                        
                        foreach ($rowMatch in $rowMatches) {
                            $row = $rowMatch.Groups[1].Value
                            
                            # Пропускаем пустые строки
                            if ([string]::IsNullOrWhiteSpace($row)) { continue }
                            
                            # Извлекаем данные из ячеек
                            $cellMatches = [regex]::Matches($row, '<td.*?>(.*?)<\/td>')
                            
                            # Проверяем, что в строке достаточно ячеек
                            if ($cellMatches.Count -ge 6) {
                                $issueName = $cellMatches[0].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                                $issueName = $issueName.Trim()
                                
                                $overall = $cellMatches[1].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                                $overall = $overall.Trim()
                                
                                $impact = $cellMatches[2].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                                $impact = $impact.Trim()
                                
                                $ease = $cellMatches[3].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                                $ease = $ease.Trim()
                                
                                $fix = $cellMatches[4].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                                $fix = $fix.Trim()
                                
                                $recommendation = $cellMatches[5].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                                $recommendation = $recommendation.Trim()
                                
                                # Добавляем уязвимость в результаты
                                if (-not [string]::IsNullOrWhiteSpace($issueName)) {
                                    $vulnerabilities[$issueName] = @{
                                        Present = 1
                                        Details = @{
                                            Overall = $overall
                                            Impact = $impact
                                            Ease = $ease
                                            Fix = $fix
                                            Recommendation = $recommendation
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        $vulnCount = $vulnerabilities.Count
        $statusColor = if ($vulnCount -gt 0) { "Green" } else { "Yellow" }
        Write-Host "Для устройства $deviceName найдено $vulnCount уязвимостей" -ForegroundColor $statusColor
        
        return @{
            DeviceName = $deviceName
            Vulnerabilities = $vulnerabilities
            FilePath = $htmlPath
        }
    }
    catch {
        Write-Host "Ошибка при обработке файла $htmlPath`: $_" -ForegroundColor Red
        return $null
    }
}








#region Основной скрипт
try {
    # Проверяем все необходимые пути
    $requiredPaths = @($NipperExePath, $StartupConfigsPath, $inputFolder, $outputFolder)
    
    if (-not (Test-Paths -Paths $requiredPaths)) {
        throw "Прерывание выполнения: один или несколько путей не существуют"
    }

    # Проверяем и создаем папки если нужно
    @($NewConfigsPath, $inputFolder, $outputFolder) | ForEach-Object {
        if (-not (Test-Path -Path $_)) {
            New-Item -ItemType Directory -Path $_ -Force | Out-Null
            Write-Host "Создана папка: $_" -ForegroundColor Yellow
        }
    }

    # Проверяем наличие nipper.exe
    if (-not (Test-Path -Path $nipperExecutable -PathType Leaf)) {
        throw "nipper.exe не найден по пути $nipperExecutable"
    }

    Write-Host "Все проверки пройдены успешно" -ForegroundColor Green

    # Шаг 1 - Ищем самую свежую папку с конфигами
    $latestFolder = Get-ChildItem -Path $StartupConfigsPath -Directory | 
                   Sort-Object CreationTime -Descending | 
                   Select-Object -First 1
    
    if (-not $latestFolder) {
        throw "В папке $StartupConfigsPath не найдено подпапок."
    }

    # Шаг 2 - Копируем файлы
    $latestFolderPath = $latestFolder.FullName
    Write-Host "Самая новая папка: $latestFolderPath"
    
    Get-ChildItem -Path $latestFolderPath -File | ForEach-Object {
        $destination = Join-Path -Path $NewConfigsPath -ChildPath $_.Name
        Copy-Item -Path $_.FullName -Destination $destination -Force
        Write-Host "Скопирован файл: $($_.Name)"
    }

    Write-Host "Копирование завершено. Файлы скопированы в: $NewConfigsPath" -ForegroundColor Green

    # Шаг 3 - Конвертируем .cfg в .txt
    $cfgFiles = Get-ChildItem -Path $NewConfigsPath -Filter *.cfg
    if ($cfgFiles.Count -eq 0) {
        Write-Host "Не найдено .cfg файлов в папке $NewConfigsPath" -ForegroundColor Yellow
    } 
    else {
        foreach ($cfgFile in $cfgFiles) {
            $newFileName = [System.IO.Path]::ChangeExtension((Join-Path -Path $inputFolder -ChildPath $cfgFile.Name), ".txt")
            Copy-Item -Path $cfgFile.FullName -Destination $newFileName -Force
            Write-Host "Файл $($cfgFile.Name) скопирован и переименован в $(Split-Path $newFileName -Leaf)"
        }
    }

    # Шаг 4 - Обрабатываем .txt файлы через Nipper
    $txtFiles = Get-ChildItem -Path $inputFolder -Filter *.txt
    $results = @()

    if ($txtFiles.Count -eq 0) {
        Write-Host "Не найдено .txt файлов в папке $inputFolder" -ForegroundColor Yellow
    } 
    else {
        foreach ($txtFile in $txtFiles) {
            try {
                $fileName = [System.IO.Path]::GetFileNameWithoutExtension($txtFile.Name)
                if ($fileName -match '^(.+?_\d{8}_\d{6})') {
                    $baseName = $matches[1]
                } else {
                    $baseName = $fileName
                }
                
                $outputFileName = "$baseName.html"
                $outputFilePath = Join-Path -Path $outputFolder -ChildPath $outputFileName
                $nipperCommand = "$nipperExecutable --input=`"$($txtFile.FullName)`" --output=`"$outputFilePath`" --procurve"

                Write-Host "Выполнение команды: $nipperCommand"
                $nipperOutput = Invoke-Expression $nipperCommand 2>&1 | Out-String
                Write-Host "Результат выполнения: $nipperOutput"

                if (Test-Path $outputFilePath) {
                    Write-Host "Файл $outputFileName успешно создан" -ForegroundColor Green
                    $result = Get-NipperVulnerabilities -htmlPath $outputFilePath
                    if ($result) { $results += $result }
                } 
                else {
                    Write-Host "Ошибка: файл $outputFileName не создан" -ForegroundColor Red
                }
            }
            catch {
                Write-Host "Ошибка при обработке файла $($txtFile.Name): $_" -ForegroundColor Red
            }
        }
    }

    # Шаг 5 - Очистка временных файлов
    if (Test-Path $inputFolder) {
        Remove-Item -Path "$inputFolder\*" -Force -ErrorAction SilentlyContinue
        Write-Host "Все файлы из $inputFolder успешно удалены" -ForegroundColor Green
    }

    # Выводим сводку по уязвимостям
    if ($results.Count -gt 0) {
        Write-Host "`nСводка по уязвимостям:"
        $results | ForEach-Object {
            Write-Host "`nУстройство: $($_.DeviceName)"
            $_.Vulnerabilities.GetEnumerator() | Sort-Object Key | ForEach-Object {
                Write-Host "  $($_.Key) (Секция: $($_.Value.Section))"
                Write-Host "    Риск: $($_.Value.Details.Overall)"
                Write-Host "    Рекомендация: $($_.Value.Details.Recommendation)"
            }
        }
    }
}
catch {
    Write-Host "Критическая ошибка: $_" -ForegroundColor Red
    exit 1
}
finally {
    Stop-Transcript
}
#endregion
