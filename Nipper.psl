<#
.SYNOPSIS
    Скрипт для анализа конфигураций сетевого оборудования с помощью Nipper
.DESCRIPTION
    Дёргает .txt файлы из inputfolder, проверяет на уязвимости и выдаёт отчёты в outputfolder
.NOTES
    File Name      : nipper_list_checker.ps1
    Author        : Ваше имя
    Prerequisite  : PowerShell 5.1+, Nipper
#>

#region Инициализация
cls

# Установка кодировки для корректной работы с русскими символами
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# Объявляем пути
$NipperExePath       = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\scanner"
$nipperExecutable    = "$NipperExePath\nipper.exe"
$StartupConfigsPath  = "\\uni-imc\cfgbak$"
$NewConfigsPath      = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\source_configs"
$inputFolder         = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\configs"
$outputFolder        = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\results"
$logFile             = "\\cu.sberbank.ru\root\Share\ОКБ\Vulnerabilities\Nipper\nipper_log_$(Get-Date -Format 'yyyyMMdd').txt"

# Создаем лог-файл
Start-Transcript -Path $logFile -Append -Force
#endregion

#region Вспомогательные функции
function Test-Paths {
    param([Parameter(Mandatory=$true)][array]$Paths)
    
    foreach ($path in $Paths) {
        if (-not (Test-Path -Path $path)) {
            Write-Host "ОШИБКА: Путь не существует - $path" -ForegroundColor Red
            return $false
        }
        Write-Host "Путь существует: $path" -ForegroundColor Green
    }
    return $true
}








function Get-NipperVulnerabilities {
    param(
        [string]$htmlPath
    )
    
    try {
        Write-Host "Обработка файла: $htmlPath" -ForegroundColor Cyan
        $htmlContent = Get-Content -Path $htmlPath -Raw -Encoding UTF8
        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($htmlPath)
        $deviceName = $fileName -replace '_\d{8}_\d{6}|\.html$'
        
        $vulnerabilities = @{}
        
        # 1. Находим основной раздел Security Audit
        if ($htmlContent -match '<div id="security">.*?<h2>2\. Security Audit<\/h2>(.*?)(?:<div id="|\z)') {
            $auditSection = $matches[1]
            
            # 2. Находим все заголовки уязвимостей (2.X, кроме последнего)
            $vulnHeaders = [regex]::Matches($auditSection, '<h3>2\.(\d+)\. (.*?)<\/h3>', [System.Text.RegularExpressions.RegexOptions]::Singleline)
            
            # 3. Определяем номер последнего подраздела (Recommendations)
            $lastSubsection = ($vulnHeaders | ForEach-Object { [int]$_.Groups[1].Value } | Measure-Object -Maximum).Maximum
            
            # 4. Собираем названия уязвимостей
            foreach ($header in $vulnHeaders) {
                $num = [int]$header.Groups[1].Value
                $name = $header.Groups[2].Value -replace '<[^>]+>','' -replace '\s+',' '
                $name = $name.Trim()
                
                if ($num -lt $lastSubsection -and -not [string]::IsNullOrEmpty($name)) {
                    $vulnerabilities[$name] = @{
                        Section = "2.$num"
                        Present = 1
                        Details = @{
                            Overall = ''
                            Impact = ''
                            Ease = ''
                            Fix = ''
                            Recommendation = ''
                        }
                    }
                }
            }
            
            # 5. Находим таблицу рекомендаций в последнем подразделе
            if ($auditSection -match "<h3>2\.$lastSubsection\..*?Recommendations.*?<\/h3>.*?<table.*?>(.*?)<\/table>") {
                $tableContent = $matches[1]
                
                # 6. Парсим строки таблицы
                $rows = [regex]::Matches($tableContent, '<tr.*?>(.*?)<\/tr>', [System.Text.RegularExpressions.RegexOptions]::Singleline)
                
                foreach ($row in $rows) {
                    $rowContent = $row.Groups[1].Value
                    
                    # Пропускаем заголовок таблицы
                    if ($rowContent -match '<th' -or -not $rowContent -match '<td') { continue }
                    
                    # Извлекаем данные из ячеек
                    $cells = [regex]::Matches($rowContent, '<td.*?>(.*?)<\/td>')
                    
                    if ($cells.Count -ge 6) {
                        $issueName = $cells[0].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                        $issueName = $issueName.Trim()
                        
                        $overall = $cells[1].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                        $overall = $overall.Trim()
                        
                        $impact = $cells[2].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                        $impact = $impact.Trim()
                        
                        $ease = $cells[3].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                        $ease = $ease.Trim()
                        
                        $fix = $cells[4].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                        $fix = $fix.Trim()
                        
                        $recommendation = $cells[5].Groups[1].Value -replace '<[^>]+>','' -replace '\s+',' '
                        $recommendation = $recommendation.Trim()
                        
                        # Обновляем данные уязвимости
                        if ($vulnerabilities.ContainsKey($issueName)) {
                            $vulnerabilities[$issueName].Details.Overall = $overall
                            $vulnerabilities[$issueName].Details.Impact = $impact
                            $vulnerabilities[$issueName].Details.Ease = $ease
                            $vulnerabilities[$issueName].Details.Fix = $fix
                            $vulnerabilities[$issueName].Details.Recommendation = $recommendation
                        }
                    }
                }
            }
        }
        
        Write-Host "Для устройства $deviceName найдено $($vulnerabilities.Count) уязвимостей" -ForegroundColor Green
        return @{
            DeviceName = $deviceName
            Vulnerabilities = $vulnerabilities
            FilePath = $htmlPath
        }
    }
    catch {
        Write-Host "Ошибка при обработке файла $htmlPath`: $_" -ForegroundColor Red
        return $null
    }
}








#region Основной скрипт
try {
    # Проверяем все необходимые пути
    $requiredPaths = @($NipperExePath, $StartupConfigsPath, $inputFolder, $outputFolder)
    
    if (-not (Test-Paths -Paths $requiredPaths)) {
        throw "Прерывание выполнения: один или несколько путей не существуют"
    }

    # Проверяем и создаем папки если нужно
    @($NewConfigsPath, $inputFolder, $outputFolder) | ForEach-Object {
        if (-not (Test-Path -Path $_)) {
            New-Item -ItemType Directory -Path $_ -Force | Out-Null
            Write-Host "Создана папка: $_" -ForegroundColor Yellow
        }
    }

    # Проверяем наличие nipper.exe
    if (-not (Test-Path -Path $nipperExecutable -PathType Leaf)) {
        throw "nipper.exe не найден по пути $nipperExecutable"
    }

    Write-Host "Все проверки пройдены успешно" -ForegroundColor Green

    # Шаг 1 - Ищем самую свежую папку с конфигами
    $latestFolder = Get-ChildItem -Path $StartupConfigsPath -Directory | 
                   Sort-Object CreationTime -Descending | 
                   Select-Object -First 1
    
    if (-not $latestFolder) {
        throw "В папке $StartupConfigsPath не найдено подпапок."
    }

    # Шаг 2 - Копируем файлы
    $latestFolderPath = $latestFolder.FullName
    Write-Host "Самая новая папка: $latestFolderPath"
    
    Get-ChildItem -Path $latestFolderPath -File | ForEach-Object {
        $destination = Join-Path -Path $NewConfigsPath -ChildPath $_.Name
        Copy-Item -Path $_.FullName -Destination $destination -Force
        Write-Host "Скопирован файл: $($_.Name)"
    }

    Write-Host "Копирование завершено. Файлы скопированы в: $NewConfigsPath" -ForegroundColor Green

    # Шаг 3 - Конвертируем .cfg в .txt
    $cfgFiles = Get-ChildItem -Path $NewConfigsPath -Filter *.cfg
    if ($cfgFiles.Count -eq 0) {
        Write-Host "Не найдено .cfg файлов в папке $NewConfigsPath" -ForegroundColor Yellow
    } 
    else {
        foreach ($cfgFile in $cfgFiles) {
            $newFileName = [System.IO.Path]::ChangeExtension((Join-Path -Path $inputFolder -ChildPath $cfgFile.Name), ".txt")
            Copy-Item -Path $cfgFile.FullName -Destination $newFileName -Force
            Write-Host "Файл $($cfgFile.Name) скопирован и переименован в $(Split-Path $newFileName -Leaf)"
        }
    }

    # Шаг 4 - Обрабатываем .txt файлы через Nipper
    $txtFiles = Get-ChildItem -Path $inputFolder -Filter *.txt
    $results = @()

    if ($txtFiles.Count -eq 0) {
        Write-Host "Не найдено .txt файлов в папке $inputFolder" -ForegroundColor Yellow
    } 
    else {
        foreach ($txtFile in $txtFiles) {
            try {
                $fileName = [System.IO.Path]::GetFileNameWithoutExtension($txtFile.Name)
                if ($fileName -match '^(.+?_\d{8}_\d{6})') {
                    $baseName = $matches[1]
                } else {
                    $baseName = $fileName
                }
                
                $outputFileName = "$baseName.html"
                $outputFilePath = Join-Path -Path $outputFolder -ChildPath $outputFileName
                $nipperCommand = "$nipperExecutable --input=`"$($txtFile.FullName)`" --output=`"$outputFilePath`" --procurve"

                Write-Host "Выполнение команды: $nipperCommand"
                $nipperOutput = Invoke-Expression $nipperCommand 2>&1 | Out-String
                Write-Host "Результат выполнения: $nipperOutput"

                if (Test-Path $outputFilePath) {
                    Write-Host "Файл $outputFileName успешно создан" -ForegroundColor Green
                    $result = Get-NipperVulnerabilities -htmlPath $outputFilePath
                    if ($result) { $results += $result }
                } 
                else {
                    Write-Host "Ошибка: файл $outputFileName не создан" -ForegroundColor Red
                }
            }
            catch {
                Write-Host "Ошибка при обработке файла $($txtFile.Name): $_" -ForegroundColor Red
            }
        }
    }

    # Шаг 5 - Очистка временных файлов
    if (Test-Path $inputFolder) {
        Remove-Item -Path "$inputFolder\*" -Force -ErrorAction SilentlyContinue
        Write-Host "Все файлы из $inputFolder успешно удалены" -ForegroundColor Green
    }

    # Выводим сводку по уязвимостям
    if ($results.Count -gt 0) {
        Write-Host "`nСводка по уязвимостям:"
        $results | ForEach-Object {
            Write-Host "`nУстройство: $($_.DeviceName)"
            $_.Vulnerabilities.GetEnumerator() | Sort-Object Key | ForEach-Object {
                Write-Host "  $($_.Key) (Секция: $($_.Value.Section))"
                Write-Host "    Риск: $($_.Value.Details.Overall)"
                Write-Host "    Рекомендация: $($_.Value.Details.Recommendation)"
            }
        }
    }
}
catch {
    Write-Host "Критическая ошибка: $_" -ForegroundColor Red
    exit 1
}
finally {
    Stop-Transcript
}
#endregion
